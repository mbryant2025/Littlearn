{"ast":null,"code":"'use strict';\n\nvar format = require('./format');\n\n/*\n * function cascade(formats)\n * Returns a function that invokes the `._format` function in-order\n * for the specified set of `formats`. In this manner we say that Formats\n * are \"pipe-like\", but not a pure pumpify implementation. Since there is no back\n * pressure we can remove all of the \"readable\" plumbing in Node streams.\n */\nfunction cascade(formats) {\n  if (!formats.every(isValidFormat)) {\n    return;\n  }\n  return function (info) {\n    var obj = info;\n    for (var i = 0; i < formats.length; i++) {\n      obj = formats[i].transform(obj, formats[i].options);\n      if (!obj) {\n        return false;\n      }\n    }\n    return obj;\n  };\n}\n\n/*\n * function isValidFormat(format)\n * If the format does not define a `transform` function throw an error\n * with more detailed usage.\n */\nfunction isValidFormat(fmt) {\n  if (typeof fmt.transform !== 'function') {\n    throw new Error(['No transform function found on format. Did you create a format instance?', 'const myFormat = format(formatFn);', 'const instance = myFormat();'].join('\\n'));\n  }\n  return true;\n}\n\n/*\n * function combine (info)\n * Returns a new instance of the combine Format which combines the specified\n * formats into a new format. This is similar to a pipe-chain in transform streams.\n * We choose to combine the prototypes this way because there is no back pressure in\n * an in-memory transform chain.\n */\nmodule.exports = function () {\n  for (var _len = arguments.length, formats = new Array(_len), _key = 0; _key < _len; _key++) {\n    formats[_key] = arguments[_key];\n  }\n  var combinedFormat = format(cascade(formats));\n  var instance = combinedFormat();\n  instance.Format = combinedFormat.Format;\n  return instance;\n};\n\n//\n// Export the cascade method for use in cli and other\n// combined formats that should not be assumed to be\n// singletons.\n//\nmodule.exports.cascade = cascade;","map":{"version":3,"names":["format","require","cascade","formats","every","isValidFormat","info","obj","i","length","transform","options","fmt","Error","join","module","exports","_len","arguments","Array","_key","combinedFormat","instance","Format"],"sources":["/Users/michaelbryant/node_modules/logform/dist/combine.js"],"sourcesContent":["'use strict';\n\nvar format = require('./format');\n\n/*\n * function cascade(formats)\n * Returns a function that invokes the `._format` function in-order\n * for the specified set of `formats`. In this manner we say that Formats\n * are \"pipe-like\", but not a pure pumpify implementation. Since there is no back\n * pressure we can remove all of the \"readable\" plumbing in Node streams.\n */\nfunction cascade(formats) {\n  if (!formats.every(isValidFormat)) {\n    return;\n  }\n  return function (info) {\n    var obj = info;\n    for (var i = 0; i < formats.length; i++) {\n      obj = formats[i].transform(obj, formats[i].options);\n      if (!obj) {\n        return false;\n      }\n    }\n    return obj;\n  };\n}\n\n/*\n * function isValidFormat(format)\n * If the format does not define a `transform` function throw an error\n * with more detailed usage.\n */\nfunction isValidFormat(fmt) {\n  if (typeof fmt.transform !== 'function') {\n    throw new Error(['No transform function found on format. Did you create a format instance?', 'const myFormat = format(formatFn);', 'const instance = myFormat();'].join('\\n'));\n  }\n  return true;\n}\n\n/*\n * function combine (info)\n * Returns a new instance of the combine Format which combines the specified\n * formats into a new format. This is similar to a pipe-chain in transform streams.\n * We choose to combine the prototypes this way because there is no back pressure in\n * an in-memory transform chain.\n */\nmodule.exports = function () {\n  for (var _len = arguments.length, formats = new Array(_len), _key = 0; _key < _len; _key++) {\n    formats[_key] = arguments[_key];\n  }\n  var combinedFormat = format(cascade(formats));\n  var instance = combinedFormat();\n  instance.Format = combinedFormat.Format;\n  return instance;\n};\n\n//\n// Export the cascade method for use in cli and other\n// combined formats that should not be assumed to be\n// singletons.\n//\nmodule.exports.cascade = cascade;"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,UAAU,CAAC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,OAAOA,CAACC,OAAO,EAAE;EACxB,IAAI,CAACA,OAAO,CAACC,KAAK,CAACC,aAAa,CAAC,EAAE;IACjC;EACF;EACA,OAAO,UAAUC,IAAI,EAAE;IACrB,IAAIC,GAAG,GAAGD,IAAI;IACd,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,OAAO,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;MACvCD,GAAG,GAAGJ,OAAO,CAACK,CAAC,CAAC,CAACE,SAAS,CAACH,GAAG,EAAEJ,OAAO,CAACK,CAAC,CAAC,CAACG,OAAO,CAAC;MACnD,IAAI,CAACJ,GAAG,EAAE;QACR,OAAO,KAAK;MACd;IACF;IACA,OAAOA,GAAG;EACZ,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASF,aAAaA,CAACO,GAAG,EAAE;EAC1B,IAAI,OAAOA,GAAG,CAACF,SAAS,KAAK,UAAU,EAAE;IACvC,MAAM,IAAIG,KAAK,CAAC,CAAC,0EAA0E,EAAE,oCAAoC,EAAE,8BAA8B,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;EAChL;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG,YAAY;EAC3B,KAAK,IAAIC,IAAI,GAAGC,SAAS,CAACT,MAAM,EAAEN,OAAO,GAAG,IAAIgB,KAAK,CAACF,IAAI,CAAC,EAAEG,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGH,IAAI,EAAEG,IAAI,EAAE,EAAE;IAC1FjB,OAAO,CAACiB,IAAI,CAAC,GAAGF,SAAS,CAACE,IAAI,CAAC;EACjC;EACA,IAAIC,cAAc,GAAGrB,MAAM,CAACE,OAAO,CAACC,OAAO,CAAC,CAAC;EAC7C,IAAImB,QAAQ,GAAGD,cAAc,CAAC,CAAC;EAC/BC,QAAQ,CAACC,MAAM,GAAGF,cAAc,CAACE,MAAM;EACvC,OAAOD,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAP,MAAM,CAACC,OAAO,CAACd,OAAO,GAAGA,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}