{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Order } from 'blockly/javascript';\nimport * as Blockly from 'blockly/core';\n\n// Export all the code generators for our custom blocks,\n// but don't register them with Blockly yet.\n// This file has no side effects!\nexport const forBlock = Object.create(null);\nforBlock['add_text'] = function (block, generator) {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const color = generator.valueToCode(block, 'COLOR', Order.ATOMIC) || \"'#ffffff'\";\n  const addText = generator.provideFunction_('addText', `function ${generator.FUNCTION_NAME_PLACEHOLDER_}(text, color) {\n\n  // Add text to the output area.\n  const outputDiv = document.getElementById('output');\n  const textEl = document.createElement('p');\n  textEl.innerText = text;\n  textEl.style.color = color;\n  outputDiv.appendChild(textEl);\n}`);\n  // Generate the function call for this block.\n  const code = `${addText}(${text}, ${color});\\n`;\n  return code;\n};\nforBlock['print'] = function (block, generator) {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  // Generate the function call for this block.\n  const code = `print(${text});\\n`;\n  return code;\n};\nforBlock['wait'] = function (block, generator) {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  // Generate the function call for this block.\n  const code = `wait(${text});\\n`;\n  return code;\n};\nforBlock['set_int'] = function (block, generator) {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const num = generator.valueToCode(block, 'NUM', Order.NONE) || \"''\";\n  // Generate the function call for this block.\n  const code = `int (${text}) = (${num});\\n`;\n  return code;\n};\nforBlock['if'] = function (block, generator) {\n  // Generate code for the 'if' block\n  var condition = generator.valueToCode(block, 'CONDITION', Order.NONE);\n\n  // If condition is blank, set it to 0\n  if (!condition) {\n    condition = '0';\n  }\n  var doBody = generator.statementToCode(block, 'DO');\n  var code = 'if (' + condition + ') {\\n' + doBody + '}';\n  return code;\n};\nforBlock['binaryOp'] = function (block, generator) {\n  const operator = block.getFieldValue('OPERATOR');\n  let valueA = generator.valueToCode(block, 'A', Order.NONE);\n  let valueB = generator.valueToCode(block, 'B', Order.NONE);\n\n  // If either value is blank, set it to 0\n\n  if (!valueA) {\n    valueA = '0';\n  }\n  if (!valueB) {\n    valueB = '0';\n  }\n  let code = '';\n\n  // Create the code based on the selected operator\n  switch (operator) {\n    case '+':\n      code = `${valueA} + ${valueB}`;\n      break;\n    case '-':\n      code = `${valueA} - ${valueB}`;\n      break;\n    case '*':\n      code = `${valueA} * ${valueB}`;\n      break;\n    case '/':\n      code = `${valueA} / ${valueB}`;\n      break;\n    case '%':\n      code = `${valueA} % ${valueB}`;\n      break;\n    case '>':\n      code = `${valueA} > ${valueB}`;\n      break;\n    case '<':\n      code = `${valueA} < ${valueB}`;\n      break;\n    default:\n      throw new Error('Unknown operator: ' + operator);\n  }\n  return [code, Order.ATOMIC];\n};\nforBlock['while'] = function (block, generator) {\n  // Generate code for the 'if' block\n  var condition = generator.valueToCode(block, 'CONDITION', Order.NONE);\n\n  // If condition is blank, set it to 0\n  if (!condition) {\n    condition = '0';\n  }\n  var doBody = generator.statementToCode(block, 'DO');\n  var code = 'while (' + condition + ') {\\n' + doBody + '}';\n  return code;\n};\nforBlock['int_var_declaration'] = function (block, generator) {\n  // Get the variable name from the 'VAR' field\n  const variableName = generator.nameDB_.getName(block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);\n\n  // Get the initial value (if provided)\n  const initialValue = generator.valueToCode(block, 'VALUE', Order.ASSIGNMENT) || '0';\n\n  // Generate the code to declare the integer variable\n  const code = `int ${variableName} = ${initialValue};`;\n  return code;\n};\nforBlock['use_variable'] = function (block, generator) {\n  // Get the variable name from the 'VAR' field\n  const variableName = generator.nameDB_.getName(block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);\n\n  // Generate the code to use the variable\n  const code = `${variableName}`;\n  return code;\n};","map":{"version":3,"names":["Order","Blockly","forBlock","Object","create","block","generator","text","valueToCode","NONE","color","ATOMIC","addText","provideFunction_","FUNCTION_NAME_PLACEHOLDER_","code","num","condition","doBody","statementToCode","operator","getFieldValue","valueA","valueB","Error","variableName","nameDB_","getName","VARIABLE_CATEGORY_NAME","initialValue","ASSIGNMENT"],"sources":["/Users/michaelbryant/Desktop/Littlearn/littlearn-web/src/blockly/generators/javascript.js"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Order} from 'blockly/javascript';\nimport * as Blockly from 'blockly/core';\n\n\n// Export all the code generators for our custom blocks,\n// but don't register them with Blockly yet.\n// This file has no side effects!\nexport const forBlock = Object.create(null);\n\nforBlock['add_text'] = function (block, generator) {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const color =\n    generator.valueToCode(block, 'COLOR', Order.ATOMIC) || \"'#ffffff'\";\n\n  const addText = generator.provideFunction_(\n      'addText',\n      `function ${generator.FUNCTION_NAME_PLACEHOLDER_}(text, color) {\n\n  // Add text to the output area.\n  const outputDiv = document.getElementById('output');\n  const textEl = document.createElement('p');\n  textEl.innerText = text;\n  textEl.style.color = color;\n  outputDiv.appendChild(textEl);\n}`\n  );\n  // Generate the function call for this block.\n  const code = `${addText}(${text}, ${color});\\n`;\n  return code;\n};\n\nforBlock['print'] = function (block, generator) {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  // Generate the function call for this block.\n  const code = `print(${text});\\n`;\n  return code;\n};\n\nforBlock['wait'] = function (block, generator) {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  // Generate the function call for this block.\n  const code = `wait(${text});\\n`;\n  return code;\n};\n\nforBlock['set_int'] = function (block, generator) {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const num = generator.valueToCode(block, 'NUM', Order.NONE) || \"''\";\n  // Generate the function call for this block.\n  const code = `int (${text}) = (${num});\\n`;\n  return code;\n};\n\nforBlock['if'] = function (block, generator) {\n  // Generate code for the 'if' block\n  var condition = generator.valueToCode(block, 'CONDITION', Order.NONE);\n\n  // If condition is blank, set it to 0\n  if (!condition) {\n    condition = '0';\n  }\n\n  var doBody = generator.statementToCode(block, 'DO');\n\n  var code = 'if (' + condition + ') {\\n' + doBody + '}';\n  \n  return code;\n};\n\nforBlock['binaryOp'] = function (block, generator) {\n  const operator = block.getFieldValue('OPERATOR');\n  \n  let valueA = generator.valueToCode(block, 'A', Order.NONE);\n  let valueB = generator.valueToCode(block, 'B', Order.NONE);\n\n  // If either value is blank, set it to 0\n\n  if (!valueA) {\n    valueA = '0';\n  }\n\n  if (!valueB) {\n    valueB = '0';\n  }\n\n  let code = '';\n\n  // Create the code based on the selected operator\n  switch (operator) {\n    case '+':\n      code = `${valueA} + ${valueB}`;\n      break;\n    case '-':\n      code = `${valueA} - ${valueB}`;\n      break;\n    case '*':\n      code = `${valueA} * ${valueB}`;\n      break;\n    case '/':\n      code = `${valueA} / ${valueB}`;\n      break;\n    case '%':\n      code = `${valueA} % ${valueB}`;\n      break;\n    case '>':\n      code = `${valueA} > ${valueB}`;\n      break;\n    case '<':\n      code = `${valueA} < ${valueB}`;\n      break;\n    default:\n      throw new Error('Unknown operator: ' + operator);\n  }\n\n  return [code, Order.ATOMIC];\n};\n\nforBlock['while'] = function (block, generator) {\n  // Generate code for the 'if' block\n  var condition = generator.valueToCode(block, 'CONDITION', Order.NONE);\n\n  // If condition is blank, set it to 0\n  if (!condition) {\n    condition = '0';\n  }\n\n  var doBody = generator.statementToCode(block, 'DO');\n\n  var code = 'while (' + condition + ') {\\n' + doBody + '}';\n  \n  return code;\n};\n\nforBlock['int_var_declaration'] = function (block, generator) {\n  // Get the variable name from the 'VAR' field\n  const variableName = generator.nameDB_.getName(\n      block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);\n\n  // Get the initial value (if provided)\n  const initialValue = generator.valueToCode(block, 'VALUE', Order.ASSIGNMENT) || '0';\n\n  // Generate the code to declare the integer variable\n  const code = `int ${variableName} = ${initialValue};`;\n\n  return code;\n};\n\nforBlock['use_variable'] = function (block, generator) {\n  // Get the variable name from the 'VAR' field\n  const variableName = generator.nameDB_.getName(\n    block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);\n\n  // Generate the code to use the variable\n  const code = `${variableName}`;\n\n  return code;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}