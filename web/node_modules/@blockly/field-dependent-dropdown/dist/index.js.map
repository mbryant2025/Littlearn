{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/field-dependent-dropdown/webpack/universalModuleDefinition","webpack://@blockly/field-dependent-dropdown/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/field-dependent-dropdown/webpack/bootstrap","webpack://@blockly/field-dependent-dropdown/webpack/runtime/define property getters","webpack://@blockly/field-dependent-dropdown/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/field-dependent-dropdown/webpack/runtime/make namespace object","webpack://@blockly/field-dependent-dropdown/./src/dependent_dropdown_options_change.ts","webpack://@blockly/field-dependent-dropdown/./src/field_dependent_dropdown.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__573__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @fileoverview An event representing when a dependent dropdown field changes\n * state.\n */\nimport * as Blockly from 'blockly/core';\n/**\n * A deep equality comparison between the two provided arrays recursively\n * comparing any child elements that are also arrays.\n * @param a The first array to compare.\n * @param b The second array to compare.\n * @returns Whether the arrays are deeply equivalent.\n */\nfunction arraysAreEquivalent(a, b) {\n    return a.length === b.length && a.every((aElement, index) => {\n        const bElement = b[index];\n        if (Array.isArray(aElement) && Array.isArray(bElement)) {\n            return arraysAreEquivalent(aElement, bElement);\n        }\n        return aElement === bElement;\n    });\n}\n/**\n * A change event representing a simultaneous change to a dropdown field's\n * options and value. The old value must be one of the old options, and the new\n * value must be one of the new options. Unlike a normal value change event,\n * it's possible for this event to change the value to something that wasn't\n * previously one of the valid options--in either direction--by also changing\n * the options at the same time.\n */\nexport class DependentDropdownOptionsChange extends Blockly.Events.BlockBase {\n    /**\n     * Construct a new DependentDropdownOptionsChange.\n     * @param block The changed block. Undefined for a blank event.\n     * @param name Name of the field affected.\n     * @param oldValue Previous value of field.\n     * @param newValue New value of field.\n     * @param oldOptions Previous options for the dropdown.\n     * @param newOptions New options for the dropdown.\n     */\n    constructor(block, name, oldValue, newValue, oldOptions, newOptions) {\n        super(block);\n        /** The name of the change event type for registering with Blockly. */\n        this.type = DependentDropdownOptionsChange.EVENT_TYPE;\n        if (!block ||\n            !name ||\n            !oldValue ||\n            !newValue ||\n            !oldOptions ||\n            !newOptions) {\n            // Blank event to be populated by fromJson.\n            return;\n        }\n        this.name = name;\n        this.oldValue = oldValue;\n        this.newValue = newValue;\n        this.oldOptions = oldOptions;\n        this.newOptions = newOptions;\n    }\n    /**\n     * Encode the event as JSON.\n     * @returns JSON representation.\n     */\n    toJson() {\n        const json = super.toJson();\n        if (!this.name ||\n            !this.oldValue ||\n            !this.newValue ||\n            !this.oldOptions ||\n            !this.newOptions) {\n            throw new Error('The changed element is undefined. Either pass all needed ' +\n                'parameters to the constructor, or call fromJson.');\n        }\n        json['name'] = this.name;\n        json['oldValue'] = this.oldValue;\n        json['newValue'] = this.newValue;\n        json['oldOptions'] = this.oldOptions;\n        json['newOptions'] = this.newOptions;\n        return json;\n    }\n    /**\n     * Decode the JSON event.\n     * @param json JSON representation.\n     * @returns The deserialized event.\n     */\n    static fromJson(json, workspace, event) {\n        const newEvent = super.fromJson(json, workspace, event);\n        newEvent.name = json['name'];\n        newEvent.oldValue = json['oldValue'];\n        newEvent.newValue = json['newValue'];\n        newEvent.oldOptions = json['oldOptions'];\n        newEvent.newOptions = json['newOptions'];\n        return newEvent;\n    }\n    /**\n     * Does this event leave all state as it was before?\n     * @returns False if something changed.\n     */\n    isNull() {\n        const valuesAreEqual = this.oldValue === this.newValue;\n        const optionsAreEquivalent = (this.oldOptions === this.newOptions) ||\n            (Array.isArray(this.oldOptions) && Array.isArray(this.newOptions) &&\n                arraysAreEquivalent(this.oldOptions, this.newOptions));\n        return valuesAreEqual && optionsAreEquivalent;\n    }\n    /**\n     * Run a change event.\n     * @param forward True if run forward, false if run backward (undo).\n     */\n    run(forward) {\n        if (!this.blockId ||\n            !this.name ||\n            !this.oldValue ||\n            !this.newValue ||\n            !this.oldOptions ||\n            !this.newOptions) {\n            console.warn('Can\\'t run uninitialized event.');\n            return;\n        }\n        const workspace = this.getEventWorkspace_();\n        const block = workspace.getBlockById(this.blockId);\n        if (!block) {\n            console.warn('Can\\'t change non-existent block: ' + this.blockId);\n            return;\n        }\n        const dropdown = block.getField(this.name);\n        if (!dropdown) {\n            console.warn('Can\\'t change non-existent dropdown field: ' + this.name);\n            return;\n        }\n        const value = forward ? this.newValue : this.oldValue;\n        const options = forward ? this.newOptions : this.oldOptions;\n        // Record the options on the dropdown for the option generator to access.\n        dropdown.dependencyData.derivedOptions = options;\n        // Re-run the option generator to update the options on the dropdown.\n        dropdown.getOptions(false);\n        // Set the value to one of the now-available options.\n        dropdown.setValue(value);\n    }\n}\n/** The name to register with Blockly for the type of event. */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nDependentDropdownOptionsChange.EVENT_TYPE = 'dropdown_options_change';\nBlockly.registry.register(Blockly.registry.Type.EVENT, DependentDropdownOptionsChange.EVENT_TYPE, DependentDropdownOptionsChange);\n","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @fileoverview A Blockly dropdown menu field where the options can change\n * depending on the value of another field.\n */\nimport * as Blockly from 'blockly/core';\nimport { DependentDropdownOptionsChange } from './dependent_dropdown_options_change';\n/**\n * A dropdown field that automatically updates its own options based on a\n * mapping from a parent field's value. The parent field must be attached to the\n * block before this child field.\n *\n * When this field is attached to a block, it will find the parent field and\n * attach a validator to the parent field that intercepts changes to its value\n * to update the options on this field. If the new validator is later removed\\\n * or replaced, then this dependent field will no longer function.\n */\nexport class FieldDependentDropdown extends Blockly.FieldDropdown {\n    /**\n     * Constructs a new FieldDependentDropdown.\n     * @param parentName The name of the parent field whose value determines this\n     *    field's available options.\n     * @param optionMapping A mapping from the possible values of the parent field\n     *    to the corresponding available options of this child field. The keys are\n     *    the possible values of the parent field, and the values are the\n     *    corresponding arrays of options for this child field.\n     * @param defaultOptions An optional fallback set of options to use if the\n     *    parent field's value does not match any of the keys in optionMapping.\n     * @param validator An optional function that is called to validate changes to\n     *    this field's value.\n     * @param config An optional map of general options used to configure the\n     *    field, such as a tooltip.\n     */\n    constructor(parentName, optionMapping, defaultOptions, validator, config) {\n        // A menu generator needs to be passed to the super constructor, but it\n        // needs to be able to reference data that hasn't been populated yet. We're\n        // not allowed to refer to \"this\" in this constructor before calling\n        // \"super\", so let's make separate structure to hold data relevant to the\n        // menu generator and populate that later.\n        const dependencyData = {};\n        // A menu option generator function for this child field that reads the\n        // derived options in the dependency data if available.\n        const menuGenerator = () => {\n            // If derivedOptions has been initialized, use that.\n            if (dependencyData.derivedOptions) {\n                return dependencyData.derivedOptions;\n            }\n            // Fall back on the options corresponding to the parent field's current\n            // value (which is fine when initializing but may be out of date when\n            // making changes since the parent field's validator function triggers\n            // this function before the parent field's value is updated).\n            // If the parent field exists, and its value is a key in the provided\n            // option mapping, use the corresponding options.\n            if (dependencyData.parentField) {\n                const value = dependencyData.parentField.getValue();\n                if (value) {\n                    const options = optionMapping[value];\n                    if (options) {\n                        return options;\n                    }\n                }\n            }\n            if (defaultOptions) {\n                return defaultOptions;\n            }\n            // Fall back on basic default options.\n            return [['', '']];\n        };\n        super(menuGenerator, validator, config);\n        this.parentName = parentName;\n        this.optionMapping = optionMapping;\n        this.defaultOptions = defaultOptions;\n        this.dependencyData = dependencyData;\n    }\n    /**\n     * Constructs a FieldDependentDropdown from a JSON arg object.\n     * @param options A JSON object providing \"parentName\" and \"optionMapping\".\n     * @returns The new field instance.\n     */\n    static fromJson(options) {\n        return new FieldDependentDropdown(options['parentName'], options['optionMapping'], options['defaultOptions'], undefined, options);\n    }\n    /**\n     * Attach this field to a block.\n     *\n     * @param block The block containing this field.\n     */\n    setSourceBlock(block) {\n        var _a;\n        super.setSourceBlock(block);\n        const parentField = block.getField(this.parentName);\n        if (!parentField) {\n            throw new Error('Could not find a parent field with the name ' +\n                this.parentName + ' for the dependent dropdown.');\n        }\n        this.dependencyData.parentField = parentField;\n        const oldValidator = parentField.getValidator();\n        // A validator function for the parent field that has the side effect of\n        // updating the options of this child dropdown field based on the new value\n        // of the parent field whenever it changes. The validator function is a good\n        // place to do this because it is called immediately while deserializing\n        // workspaces before the following fields are deserialized, so when the\n        // child value is deserialized the appropriate options will already be\n        // available. If the parent already had a validator function, it will be\n        // composed with this one and the new value returned from it will be the\n        // basis for determining the new available options.\n        parentField.setValidator((newValue) => {\n            if (oldValidator) {\n                const validatedValue = oldValidator(newValue);\n                // If a validator returns null, that means the new value is invalid and\n                // the change should be canceled.\n                if (validatedValue === null) {\n                    return null;\n                }\n                // If a validator returns undefined, that means no change. Otherwise,\n                // use the returned value as the new value.\n                if (validatedValue !== undefined) {\n                    newValue = validatedValue;\n                }\n            }\n            this.updateOptionsBasedOnNewValue(newValue);\n            return newValue;\n        });\n        this.updateOptionsBasedOnNewValue((_a = parentField.getValue()) !== null && _a !== void 0 ? _a : undefined);\n    }\n    /**\n     * Updates the options of this child dropdown field based on the new value of\n     * the parent field.\n     * @param newValue The newly assigned value.\n     */\n    updateOptionsBasedOnNewValue(newValue) {\n        if (newValue == undefined) {\n            return;\n        }\n        const block = this.getSourceBlock();\n        if (!block) {\n            throw new Error('Could not validate a field that is not attached to a block: ' +\n                this.name);\n        }\n        const oldChildValue = this.getValue();\n        const oldChildOptions = this.getOptions(false);\n        let newChildOptions = this.optionMapping[newValue];\n        if (!newChildOptions) {\n            if (this.defaultOptions) {\n                newChildOptions = this.defaultOptions;\n            }\n            else {\n                console.warn('Could not find child options for the parent value: ' + newValue);\n                return;\n            }\n        }\n        // If the child field's value is still available in the new options, keep\n        // it, otherwise change the field's value to the first available option.\n        const newOptionsIncludeOldValue = (newChildOptions.find((option) => option[1] == oldChildValue) !=\n            undefined);\n        const newChildValue = newOptionsIncludeOldValue ?\n            oldChildValue :\n            newChildOptions[0][1];\n        // Record the options so that the option generator can access them.\n        this.dependencyData.derivedOptions = newChildOptions;\n        // Re-run the option generator to update the options on the dropdown.\n        this.getOptions(false);\n        // Update this child field's value without broadcasting the normal change\n        // event. The normal value change event can't be properly undone, because\n        // the old value may not be one of the currently valid options, so a custom\n        // change event will be broadcast instead that handles swapping the options\n        // and the value at the same time.\n        Blockly.Events.disable();\n        this.setValue(newChildValue);\n        Blockly.Events.enable();\n        if (Blockly.Events.getRecordUndo()) {\n            if (!Blockly.Events.getGroup()) {\n                // Start a change group before the change event. The change event for\n                // the parent field value will be created after this function returns\n                // and will be part of the same group.\n                Blockly.Events.setGroup(true);\n                // Clear the change group later, after all related events have been\n                // broadcast, but before the user performs any more actions.\n                setTimeout(() => Blockly.Events.setGroup(false));\n            }\n            // Record that the child field's options and value have changed.\n            Blockly.Events.fire(new DependentDropdownOptionsChange(block, this.name, oldChildValue !== null && oldChildValue !== void 0 ? oldChildValue : undefined, newChildValue !== null && newChildValue !== void 0 ? newChildValue : undefined, oldChildOptions, newChildOptions));\n        }\n    }\n}\nBlockly.fieldRegistry.register('field_dependent_dropdown', FieldDependentDropdown);\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","arraysAreEquivalent","b","length","every","aElement","index","bElement","Array","isArray","DependentDropdownOptionsChange","constructor","block","name","oldValue","newValue","oldOptions","newOptions","super","type","EVENT_TYPE","toJson","json","Error","static","workspace","event","newEvent","fromJson","isNull","valuesAreEqual","optionsAreEquivalent","run","forward","blockId","console","warn","getEventWorkspace_","getBlockById","dropdown","getField","options","dependencyData","derivedOptions","getOptions","setValue","FieldDependentDropdown","parentName","optionMapping","defaultOptions","validator","config","parentField","getValue","setSourceBlock","_a","oldValidator","getValidator","setValidator","validatedValue","updateOptionsBasedOnNewValue","getSourceBlock","oldChildValue","oldChildOptions","newChildOptions","newChildValue","find","option","setTimeout"],"sourceRoot":""}